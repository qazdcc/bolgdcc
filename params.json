{
  "name": "Bolgdcc",
  "tagline": "jdbcTemplate 详细使用 ",
  "body": "RowMapper：用于将结果集每行数据转换为需要的类型，用户需实现方法mapRow(ResultSet rs, int rowNum)来完成将每行数据转换为相应的类型。         \r\n \r\nRowCallbackHandler：用于处理ResultSet的每一行结果，用户需实现方法processRow(ResultSet rs)来完成处理，在该回调方法中无需执行rs.next()，该操作由JdbcTemplate来执行，用户只需按行获取数据然后处理即可。\r\n \r\nResultSetExtractor：用于结果集数据提取，用户需实现方法extractData(ResultSet rs)来处理结果集，用户必须处理整个结果集；\r\n \r\n \r\n \r\n \r\n \r\n//1.查询一行数据并返回int型结果\r\n \r\njdbcTemplate.queryForInt(\"select count(*) from test\");\r\n \r\n//2. 查询一行数据并将该行数据转换为Map返回\r\n \r\njdbcTemplate.queryForMap(\"select * from test where name='name5'\");\r\n \r\n//3.查询一行任何类型的数据，最后一个参数指定返回结果类型\r\n \r\njdbcTemplate.queryForObject(\"select count(*) from test\", Integer.class);\r\n \r\n//4.查询一批数据，默认将每行数据转换为Map     \r\n \r\njdbcTemplate.queryForList(\"select * from test\");\r\n \r\n//5.只查询一列数据列表，列类型是String类型，列名字是name\r\n \r\njdbcTemplate.queryForList(\"\r\n \r\nselect name from test where name=?\", new Object[]{\"name5\"}, String.class);\r\n \r\n//6.查询一批数据，返回为SqlRowSet，类似于ResultSet，但不再绑定到连接上\r\n \r\nSqlRowSet rs = jdbcTemplate.queryForRowSet(\"select * from test\");\r\n \r\n \r\n \r\n其中下面这些查询方法支持多列结果集：\r\n \r\nList query(String sql, RowMapper rowMapper)\r\n \r\nMap queryForMap(String sql)\r\n \r\nObject queryForObject(String sql, RowMapper rowMapper)\r\n \r\nList queryForList(String sql)\r\n \r\n其他不支持多列结果集的查询方法则会抛出IncorrectResultSetColumnCountException异常。\r\n \r\n \r\n \r\n从上面的结果可以看出只有返回值类型为List的方法可以接收零到多行结果集而不抛出异常，\r\n \r\n所以在使用query方法及queryForXXX方法时需要注意处理EmptyResultDataAccessException和IncorrectResultSizeDataAccessException这两个异常，\r\n \r\n这两个异常反映出数据库表中数据可能出现了缺失或冗余。如果返回值不符合期望值时，则需要排查业务流程或者数据了。\r\n \r\n \r\n \r\n最后我们来看看RowMapper接口，这个接口的实现类的功能是将结果集中的每一行数据封装成用户定义的结构，所以在查询方法中经常会被用到。\r\n \r\nSpring框架为我们提供了BeanPropertyRowMapper/ParameterizedBeanPropertyRowMapper，ColumnMapRowMapper和SingleColumnRowMapper这三大便利类。\r\n \r\nBeanPropertyRowMapper类与ParameterizedBeanPropertyRowMapper类的功能完全相同，当POJO对象和数据库表字段完全对应或者驼峰式与下划线式对应时，\r\n \r\n该类会根据构造函数中传递的class来自动填充数据。只是ParameterizedBeanPropertyRowMapper类使用泛型需要JDK5+支持。这里需要注意虽然这两个类提供了便利，\r\n \r\n但是由于使用反射导致性能下降，所以如果需要高性能则还是需要自己去实现RowMapper接口来包装数据。\r\n \r\nColumnMapRowMapper类返回一个List对象，对象中的每一个元素都是一个以列名为key的Map对象。\r\n \r\nSingleColumnRowMapper类也返回一个List对象，对象中的每个元素是数据库中的某列的值。注意结果集必须是单列，不然会抛出IncorrectResultSetColumnCountException异常。\r\n \r\n \r\n \r\nJdbcTemplate是core包的核心类。它替我们完成了资源的创建以及释放工作，从而简化了我们对JDBC的使用。它还可以帮助我们避免一些常见的错误，比如忘记关闭数据库连接。\r\n \r\nJdbcTemplate将完成JDBC核心处理流程，比如SQL语句的创建、执行，而把SQL语句的生成以及查询结果的提取工作留给我们的应用代码。它可以完成SQL查询、更新以及调用存储过程，\r\n \r\n可以对ResultSet进行遍历并加以提取。它还可以捕获JDBC异常并将其转换成org.springframework.dao包中定义的，通用的，信息更丰富的异常。\r\n \r\n使用JdbcTemplate进行编码只需要根据明确定义的一组契约来实现回调接口。PreparedStatementCreator回调接口通过给定的Connection创建一个PreparedStatement，\r\n \r\n包含SQL和任何相关的参数。CallableStatementCreateor实现同样的处理，只不过它创建的是CallableStatement。RowCallbackHandler接口则从数据集的每一行中提取值。\r\n \r\n我们可以在一个service实现类中通过传递一个DataSource引用来完成JdbcTemplate的实例化，也可以在application context中配置一个JdbcTemplate bean，\r\n \r\n来供service使用。需要注意的是DataSource在application context总是配制成一个bean，第一种情况下，DataSource bean将传递给service，\r\n \r\n第二种情况下DataSource bean传递给JdbcTemplate bean。因为JdbcTemplate使用回调接口和SQLExceptionTranslator接口作为参数，所以一般情况下没有必要通过继承JdbcTemplate来定义其子类。\r\n \r\nJdbcTemplate中使用的所有SQL将会以“DEBUG”级别记入日志（一般情况下日志的category是JdbcTemplate相应的全限定类名，不过如果需要对JdbcTemplate进行定制的话，可能是它的子类名）。\r\n \r\n \r\n \r\n1. NamedParameterJdbcTemplate类\r\n \r\nNamedParameterJdbcTemplate类增加了在SQL语句中使用命名参数的支持。在此之前，在传统的SQL语句中，参数都是用'?'占位符来表示的。NamedParameterJdbcTemplate类内部封装了一个普通的JdbcTemplate，\r\n \r\n并作为其代理来完成大部分工作。下面的内容主要针对NamedParameterJdbcTemplate与JdbcTemplate的不同之处来加以说明，即如何在SQL语句中使用命名参数。\r\n \r\n通过下面的例子我们可以更好地了解NamedParameterJdbcTemplate的使用模式（在后面我们还有更好的使用方式）。\r\n \r\n// some JDBC-backed DAO class...\r\n \r\npublic int countOfActorsByFirstName(String firstName) {\r\n \r\nString sql = \"select count(0) from T_ACTOR where first_name = :first_name\";\r\n \r\nNamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(this.getDataSource());\r\n \r\nSqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName);\r\n \r\nreturn template.queryForInt(sql, namedParameters);\r\n \r\n}\r\n \r\n在上面例子中，sql变量使用了命名参数占位符“first_name”，与其对应的值存在namedParameters变量中（类型为MapSqlParameterSource）。\r\n \r\n如果你喜欢的话，也可以使用基于Map风格的名值对将命名参数传递给NamedParameterJdbcTemplate（NamedParameterJdbcTemplate实现了NamedParameterJdbcOperations接口，\r\n \r\n剩下的工作将由调用该接口的相应方法来完成，这里我们就不再赘述）：\r\n \r\n// some JDBC-backed DAO class...\r\n \r\npublic int countOfActorsByFirstName(String firstName) {\r\n \r\nString sql = \"select count(0) from T_ACTOR where first_name = :first_name\";\r\n \r\nNamedParameterJdbcTemplate template = new NamedParameterJdbcTemplate(this.getDataSource());\r\n \r\nMap namedParameters = new HashMap();\r\n \r\nnamedParameters.put(\"first_name\", firstName);\r\n \r\nreturn template.queryForInt(sql, namedParameters);\r\n \r\n}\r\n \r\n另外一个值得一提的特性是与NamedParameterJdbcTemplate位于同一个包中的SqlParameterSource接口。在前面的代码片断中我们已经看到了该接口的实现\r\n \r\n（即MapSqlParameterSource类），SqlParameterSource可以用来作为NamedParameterJdbcTemplate命名参数的来源。MapSqlParameterSource类是一个非常简单的实现，\r\n \r\n它仅仅是一个java.util.Map适配器，当然其用法也就不言自明了（如果还有不明了的，可以在Spring的JIRA系统中要求提供更多的相关资料）。\r\n \r\nSqlParameterSource接口的另一个实现－－BeanPropertySqlParameterSource为我们提供了更有趣的功能。该类包装一个类似JavaBean的对象，所需要的命名参数值将由包装对象提供，\r\n \r\n大家必须牢记一点：NamedParameterJdbcTemplate类内部包装了一个标准的JdbcTemplate类。如果你需要访问其内部的JdbcTemplate实例（比如访问JdbcTemplate的一些方法）\r\n \r\n那么你需要使用getJdbcOperations()方法返回的JdbcOperations接口。（JdbcTemplate实现了JdbcOperations接口）。NamedParameterJdbcTemplate类是线程安全的，\r\n \r\n该类的最佳使用方式不是每次操作的时候实例化一个新的NamedParameterJdbcTemplate，而是针对每个DataSource只配置一个NamedParameterJdbcTemplate实例\r\n \r\n（比如在Spring IoC容器中使用Spring IoC来进行配置），然后在那些使用该类的DAO中共享该实例。\r\n \r\n \r\n \r\n2.SimpleJdbcTemplate类\r\n \r\n请注意该类所提供的功能仅适用于Java 5 (Tiger)。\r\n \r\nSimpleJdbcTemplate类是JdbcTemplate类的一个包装器（wrapper），它利用了Java 5的一些语言特性，比如Varargs和Autoboxing。对那些用惯了Java 5的程序员，这些新的语言特性还是很好用的。\r\n \r\nSimpleJdbcTemplate 类利用Java 5的语法特性带来的好处可以通过一个例子来说明。在下面的代码片断中我们首先使用标准的JdbcTemplate进行数据访问，接下来使用SimpleJdbcTemplate做同样的事情。\r\n \r\n// classic JdbcTemplate-style...\r\n \r\npublic Actor findActor(long id) {\r\n \r\nString sql = \"select id, first_name, last_name from T_ACTOR where id = ?\";\r\n \r\nRowMapper mapper = new RowMapper() {\r\n \r\npublic Object mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n \r\nActor actor = new Actor();\r\n \r\nactor.setId(rs.getLong(Long.valueOf(rs.getLong(\"id\"))));\r\n \r\nactor.setFirstName(rs.getString(\"first_name\"));\r\n \r\nactor.setLastName(rs.getString(\"last_name\"));\r\n \r\nreturn actor;\r\n \r\n}\r\n \r\n};\r\n \r\n// normally this would be dependency injected of course...\r\n \r\nJdbcTemplate jdbcTemplate = new JdbcTemplate(this.getDataSource());\r\n \r\n// notice the cast, and the wrapping up of the 'id' argument\r\n \r\n// in an array, and the boxing of the 'id' argument as a reference type\r\n \r\nreturn (Actor) jdbcTemplate.queryForObject(sql, mapper, new Object[] {Long.valueOf(id)});\r\n \r\n}\r\n \r\n下面是同一方法的另一种实现，惟一不同之处是我们使用了SimpleJdbcTemplate，这样代码显得更加清晰。\r\n \r\n// SimpleJdbcTemplate-style...\r\n \r\npublic Actor findActor(long id) {\r\n \r\nString sql = \"select id, first_name, last_name from T_ACTOR where id = ?\";\r\n \r\nParameterizedRowMapper<Actor> mapper = new ParameterizedRowMapper<Actor>() {\r\n \r\n// notice the return type with respect to Java 5 covariant return types\r\n \r\npublic Actor mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n \r\nActor actor = new Actor();\r\n \r\nactor.setId(rs.getLong(\"id\"));\r\n \r\nactor.setFirstName(rs.getString(\"first_name\"));\r\n \r\nactor.setLastName(rs.getString(\"last_name\"));\r\n \r\nreturn actor;\r\n \r\n}\r\n \r\n};\r\n \r\n// again, normally this would be dependency injected of course...\r\n \r\nSimpleJdbcTemplate simpleJdbcTemplate = new SimpleJdbcTemplate(this.getDataSource());\r\n \r\nreturn simpleJdbcTemplate.queryForObject(sql, mapper, id);\r\n \r\n}\r\n \r\n \r\n \r\n \r\n \r\n11.3. 控制数据库连接\r\n \r\n11.3.1. DataSourceUtils类\r\n \r\nDataSourceUtils作为一个帮助类提供易用且强大的数据库访问能力， 我们可以使用该类提供的静态方法从JNDI获取数据库连接以及在必要的时候关闭之。 \r\n \r\n它提供支持线程绑定的数据库连接（比如使用DataSourceTransactionManager 的时候，将把数据库连接绑定到当前的线程上）。\r\n \r\n注：getDataSourceFromJndi(..)方法主要用于那些没有使用bean factory 或者application context的场合。如果使用application context，\r\n \r\n那么最好是在JndiObjectFactoryBean中配置bean或者直接使用 JdbcTemplate实例。JndiObjectFactoryBean \r\n \r\n能够通过JNDI获取DataSource并将DataSource作为引用参数传递给其他bean。 这样，在不同的DataSource之间切换只需要修改配置文件即可， \r\n \r\n甚至我们可以用一个非JNDI的DataSource来替换FactoryBean定义！\r\n \r\n11.3.2. SmartDataSource接口\r\n \r\nSmartDataSource是DataSource 接口的一个扩展，用来提供数据库连接。使用该接口的类在指定的操作之后可以检查是否需要关闭连接。 \r\n \r\n该接口在某些情况下非常有用，比如有些情况需要重用数据库连接。\r\n \r\n11.3.3. AbstractDataSource类\r\n \r\nAbstractDataSource是一个实现了DataSource 接口的abstract基类。它实现了DataSource接口的 一些无关痛痒的方法，如果你需要实现自己的DataSource，那么继承该类是个好主意。\r\n \r\n11.3.4. SingleConnectionDataSource类\r\n \r\nSingleConnectionDataSource是SmartDataSource接口 的一个实现，其内部包装了一个单连接。该连接在使用之后将不会关闭，很显然它不能在多线程 的环境下使用。\r\n \r\n当客户端代码调用close方法的时候，如果它总是假设数据库连接来自连接池（就像使用持久化工具时一样）， 你应该将suppressClose设置为true。 这样，通过该类获取的将是代理连接\r\n \r\n（禁止关闭）而不是原有的物理连接。 需要注意的是，我们不能把使用该类获取的数据库连接造型（cast）为Oracle Connection之类的本地数据库连接。\r\n \r\nSingleConnectionDataSource主要在测试的时候使用。 它使得测试代码很容易脱离应用服务器而在一个简单的JNDI环境下运行。 与DriverManagerDataSource不同的是，\r\n \r\n它始终只会使用同一个数据库连接， 从而避免每次建立物理连接的开销。\r\n \r\n11.3.5. DriverManagerDataSource类\r\n \r\nDriverManagerDataSource类实现了SmartDataSource接口。在applicationContext.xml中可以使用 bean properties来设置JDBC Driver属性，该类每次返回的都是一个新的连接。\r\n \r\n该类主要在测试以及脱离J2EE容器的独立环境中使用。它既可以用来在application context中作为一个DataSource bean，也可以在简单的JNDI环境下使用。\r\n \r\n 由于Connection.close()仅仅只是简单的关闭数据库连接，因此任何能够获取DataSource的持久化代码都能很好的工作。不过使用JavaBean风格的连接池 （比如commons-dbcp）\r\n \r\n 也并非难事。即使是在测试环境下，使用连接池也是一种比使用DriverManagerDataSource更好的做法。\r\n \r\n11.3.6. TransactionAwareDataSourceProxy类\r\n \r\nTransactionAwareDataSourceProxy作为目标DataSource的一个代理， 在对目标DataSource包装的同时，还增加了Spring的事务管理能力， 在这一点上，这个类的功能非常像J2EE服务器所提供的事务化的JNDIDataSource。\r\n \r\n该类几乎很少被用到，除非现有代码在被调用的时候需要一个标准的 JDBC DataSource接口实现作为参数。 这种情况下，这个类可以使现有代码参与Spring的事务管理。\r\n \r\n通常最好的做法是使用更高层的抽象 来对数据源进行管理，比如JdbcTemplate和DataSourceUtils等等。\r\n \r\n11.3.7. DataSourceTransactionManager类\r\n \r\nDataSourceTransactionManager类是PlatformTransactionManager接口的一个实现，用于处理单JDBC数据源。 它将从指定DataSource取得的JDBC连接绑定到当前线程，\r\n \r\n因此它也支持了每个数据源对应到一个线程。我们推荐在应用代码中使用DataSourceUtils.getConnection(DataSource)来获取 JDBC连接，而不是使用J2EE标准的DataSource.getConnection。\r\n \r\n因为前者将抛出 unchecked的org.springframework.dao异常，而不是checked的SQLException异常。Spring Framework中所有的类（比如 JdbcTemplate）都采用这种做法。\r\n \r\n如果不需要和这个 DataSourceTransactionManager类一起使用，DataSourceUtils 提供的功能跟一般的数据库连接策略没有什么两样，因此它可以在任何场景下使用。\r\n \r\nDataSourceTransactionManager类支持定制隔离级别，以及对SQL语句查询超时的设定。 为了支持后者，应用代码必须使用JdbcTemplate或者在每次创建SQL语句时调用DataSourceUtils.applyTransactionTimeout方法。\r\n \r\n在使用单个数据源的情形下，你可以用DataSourceTransactionManager来替代JtaTransactionManager， 因为DataSourceTransactionManager不需要容器支持JTA。\r\n \r\n如果你使用DataSourceUtils.getConnection(DataSource)来获取 JDBC连接，二者之间的切换只需要更改一些配置。最后需要注意的一点就是JtaTransactionManager不支持隔离级别的定制！\r\n \r\n \r\n \r\n用于查询的回调接口定义主要有以下三种： \r\n \r\norg.springframework.jdbc.core.ResultSetExtractor.  基本上属于JdbcTemplate内部使用的Callback接口，相对于下面两个Callback接口来说，ResultSetExtractor拥有更多的控制权，\r\n \r\n因为使用它，你需要自行处理ResultSet： \r\n \r\npublic interface ResultSetExtractor \r\n \r\n{ Object extractData(ResultSet rs) throws SQLException, DataAccessException; } \r\n \r\n在直接处理完ResultSet之后，你可以将处理后的结果以任何你想要的形式包装后返回。 \r\n \r\norg.springframework.jdbc.core.RowCallbackHandler.  RowCallbackHandler相对于ResultSetExtractor来说，仅仅关注单行结果的处理，\r\n \r\n处理后的结果可以根据需要存放到当前RowCallbackHandler对象内或者使用JdbcTemplate的程序上下文中，当然，这个完全是看个人爱好了。 RowCallbackHandler的定义如下： \r\n \r\npublic interface RowCallbackHandler \r\n \r\n{ void processRow(ResultSet rs) throws SQLException; } \r\n \r\norg.springframework.jdbc.core.RowMapper.  ResultSetExtractor的精简版，功能类似于RowCallbackHandler，也只关注处理单行的结果，不过，处理后的结果会由ResultSetExtractor实现类进行组合。 RowMapper的接口定义如下： \r\n \r\npublic interface RowMapper \r\n \r\n{ Object mapRow(ResultSet rs, int rowNum) throws SQLException; } \r\n \r\n为了说明这三种Callback接口的使用和相互之间的区别，我们暂且设定如下场景： \r\n \r\n数据库表customer中存在多行信息，对该表查询后，我们需要将每一行的顾客信息都映射到域对象Customer中，并以java.util.List的形式返回所有的查询结果。 \r\n \r\n使用三种Callback接口作为参数的query方法的返回值不同: \r\n \r\n以ResultSetExtractor作为方法参数的query方法返回Object型结果，要使用查询结果，我们需要对其进行强制转型； \r\n \r\n以RowMapper接口作为方法参数的query方法直接返回List型的结果； \r\n \r\n以RowCallbackHandler作为方法参数的query方法，返回值为void； \r\n \r\n使用ResultSetExtractor作为Callback接口处理查询结果，我们需要自己声明集合类，自己遍历ResultSet，自己根据每行数据组装Customer对象，自己将组装后的Customer对象添加到集合类中，方法最终只负责将组装完成的集合返回； \r\n \r\n使用RowMapper比直接使用ResultSetExtractor要方便的多，只负责处理单行结果就行，现在，我们只需要将单行的结果组装后返回就行，剩下的工作，全部都是JdbcTemplate内部的事情了。 实际上，JdbcTemplae内部会使用一个ResultSetExtractor实现类来做其余的工作\r\n \r\nJdbcTemplae内部使用的这个ResultSetExtractor实现类为org.springframework.jdbc.core.RowMapperResultSetExtractor， 它内部持有一个RowMapper实例的引用，当处理结果集的时候，会将单行数据的处理委派给其所持有的RowMapper实例，而其余工作它负责： \r\n \r\n \r\n \r\npublic Object extractData(ResultSet rs) throws SQLException { \r\n \r\nList results = (this.rowsExpected > 0 ? new ArrayList(this.rowsExpected) : new ArrayList()); \r\n \r\nint rowNum = 0; \r\n \r\nwhile (rs.next()) { \r\n \r\nresults.add(this.rowMapper.mapRow(rs, rowNum++)); \r\n \r\n} \r\n \r\nreturn results; \r\n \r\n} \r\n \r\n这下应该清楚为啥RowMapper为啥就处理单行结果就能完成ResultSetExtractor颇费周折的工作了吧？！ \r\n \r\nRowCallbackHandler虽然与RowMapper同是处理单行数据，不过，除了要处理单行结果，它还得负责最终结果的组装和获取工作，在这里我们是使用当前上下文声明的List取得最终查询结果， 不过，我们也可以单独声明一个RowCallbackHandler实现类，\r\n \r\n在其中声明相应的集合类，这样，我们可以通过该RowCallbackHandler实现类取得最终查询结果： \r\n \r\npublic class GenericRowCallbackHandler implements RowCallbackHandler { \r\n \r\nprivate List collections = new ArrayList(); \r\n \r\npublic void processRow(ResultSet rs) throws SQLException { \r\n \r\nCustomer customer = new Customer(); \r\n \r\ncustomer.setFirstName(rs.getString(1)); \r\n \r\ncustomer.setLastName(rs.getString(2)); \r\n \r\ncollections.add(customer); \r\n \r\n} \r\n \r\n \r\n \r\npublic List getResults() \r\n \r\n{ \r\n \r\nreturn collections; \r\n \r\n} \r\n \r\n} \r\n \r\n \r\n \r\nGenericRowCallbackHandler handler = new GenericRowCallbackHandler(); \r\n \r\njdbcTemplate.query(\"select * from customer\",handler()); \r\n \r\nList customerList = handler.getResults(); \r\n \r\n该使用方式是明了了，不过GenericRowCallbackHandler重用性不佳。 \r\n \r\nRowCallbackHandler因为也是处理单行数据，所以，总得有人来做遍历ResultSet的工作，这个人其实也是一个ResultSetExtractor实现类， 它是JdbcTemplate一个内部静态类，名为RowCallbackHandlerResultSetExtractor，一看它的定义你就知道奥秘之所在了： \r\n \r\n \r\n \r\nprivate static class RowCallbackHandlerResultSetExtractor implements ResultSetExtractor { \r\n \r\n \r\n \r\nprivate final RowCallbackHandler rch; \r\n \r\n \r\n \r\npublic RowCallbackHandlerResultSetExtractor(RowCallbackHandler rch) { \r\n \r\nthis.rch = rch; \r\n \r\n} \r\n \r\n \r\n \r\npublic Object extractData(ResultSet rs) throws SQLException { \r\n \r\nwhile (rs.next()) { \r\n \r\nthis.rch.processRow(rs); \r\n \r\n} \r\n \r\nreturn null; \r\n \r\n} \r\n \r\n} \r\n \r\n总的来说，内部工作归根结底是由ResultSetExtractor做了，RowCallbackHandler和RowMapper只是为了帮助我们简化使用上的操作而已。 所以，实际使用中，RowCallbackHandler和RowMapper才是我们最常用的选择。\r\n \r\n\r\n\r\n\r\npackage jdbc;\r\n\r\n \r\n\r\nimport java.sql.PreparedStatement;\r\n\r\nimport java.sql.ResultSet;\r\n\r\nimport java.sql.SQLException;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport java.util.Arrays;\r\n\r\nimport java.util.Calendar;\r\n\r\nimport java.util.Collection;\r\n\r\nimport java.util.Date;\r\n\r\nimport java.util.HashMap;\r\n\r\nimport java.util.List;\r\n\r\nimport java.util.Map;\r\n\r\n \r\n\r\nimport org.junit.Test;\r\n\r\nimport org.junit.runner.RunWith;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport org.springframework.jdbc.core.BatchPreparedStatementSetter;\r\n\r\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\r\n\r\nimport org.springframework.jdbc.core.ColumnMapRowMapper;\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\n\r\nimport org.springframework.jdbc.core.PreparedStatementSetter;\r\n\r\nimport org.springframework.jdbc.core.RowMapper;\r\n\r\nimport org.springframework.jdbc.core.SingleColumnRowMapper;\r\n\r\nimport org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;\r\n\r\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\r\n\r\nimport org.springframework.jdbc.core.namedparam.SqlParameterSource;\r\n\r\nimport org.springframework.jdbc.support.GeneratedKeyHolder;\r\n\r\nimport org.springframework.test.context.ContextConfiguration;\r\n\r\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\r\n\r\n \r\n\r\nimport jdbc.model.Person;\r\n\r\nimport jdbc.service.PersonService;\r\n\r\n \r\n\r\n@ContextConfiguration(locations = \"classpath:beans.xml\")\r\n\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n\r\npublic class JunitTest {\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private JdbcTemplate jdbcTemplate;\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private PersonService personService;\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void query1() {\r\n\r\n        List<Person> a = jdbcTemplate.query(\"select * from person where id = ? or name = ?\", new Object[] { 1, \"张三\" },\r\n\r\n                new RowMapper<Person>() {\r\n\r\n                    @Override\r\n\r\n                    public Person mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\r\n                        Person p = new Person();\r\n\r\n                        p.setId(rs.getInt(\"id\"));\r\n\r\n                        p.setName(rs.getString(\"name\"));\r\n\r\n                        p.setAge(rs.getInt(\"age\"));\r\n\r\n                        p.setPass(rs.getString(\"pass\"));\r\n\r\n                        return p;\r\n\r\n                    }\r\n\r\n                });\r\n\r\n        System.out.println(a);\r\n\r\n \r\n\r\n        Map<String, Object> map = new HashMap<>();\r\n\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n\r\n        arr.add(1);\r\n\r\n        arr.add(3);\r\n\r\n        map.put(\"ids\", arr);\r\n\r\n        List<Person> b = namedParameterJdbcTemplate.query(\"select * from person where id IN (:ids)\", map,\r\n\r\n                new BeanPropertyRowMapper<>(Person.class));\r\n\r\n        System.out.println(b);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void save1() {\r\n\r\n        Person p = new Person();\r\n\r\n        p.setId(5);\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Ead\");\r\n\r\n        p.setPass(\"00000\");\r\n\r\n        jdbcTemplate.update(\"insert into person(id,name,age,pass) values(?,?,?,?)\",\r\n\r\n                new Object[] { p.getId(), p.getName(), p.getAge(), p.getPass() });\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void save3() {\r\n\r\n        Calendar c = Calendar.getInstance();\r\n\r\n        jdbcTemplate.update(\"insert into testtime(time) values(?)\", new Object[] { c.getTime() });\r\n\r\n    }\r\n\r\n \r\n\r\n     \r\n\r\n    @Test\r\n\r\n    public void save2() {\r\n\r\n        Person p = new Person();\r\n\r\n        p.setId(6);\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Ead\");\r\n\r\n        p.setPass(\"00000\");\r\n\r\n        Person p1 = new Person();\r\n\r\n        p1.setId(6);\r\n\r\n        p1.setAge(11);\r\n\r\n        p1.setName(\"Ead\");\r\n\r\n        p1.setPass(\"00000\");\r\n\r\n        List<Person> list = new ArrayList<>();\r\n\r\n        list.add(p);\r\n\r\n        jdbcTemplate.update(\"insert into person(name,age,pass) values(?,?,?)\", new PreparedStatementSetter() {\r\n\r\n            @Override\r\n\r\n            public void setValues(PreparedStatement ps) throws SQLException {\r\n\r\n                ps.setString(1, p.getName());\r\n\r\n                ps.setInt(2, p.getAge());\r\n\r\n                ps.setString(3, p.getPass());\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(personService.getPersonList());\r\n\r\n \r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void update1() {\r\n\r\n        Person p = new Person();\r\n\r\n        p.setId(6);\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Eada\");\r\n\r\n        p.setPass(\"232323\");\r\n\r\n        jdbcTemplate.update(\"update person set name=？ where id=?\", new PreparedStatementSetter() {\r\n\r\n            @Override\r\n\r\n            public void setValues(PreparedStatement ps) throws SQLException {\r\n\r\n                ps.setString(1, p.getName());\r\n\r\n                ps.setInt(2, p.getId());\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void update2() {\r\n\r\n        Person p = new Person();\r\n\r\n        p.setId(6);\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Eada\");\r\n\r\n        p.setPass(\"232323\");\r\n\r\n        jdbcTemplate.update(\"update person set name=? where id=?\", new PreparedStatementSetter() {\r\n\r\n            @Override\r\n\r\n            public void setValues(PreparedStatement ps) throws SQLException {\r\n\r\n                ps.setString(1, p.getName());\r\n\r\n                ps.setInt(2, p.getId());\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void delete() {\r\n\r\n        jdbcTemplate.update(\"delete from person where id = ?\", new Object[] { 5 },\r\n\r\n                new int[] { java.sql.Types.INTEGER });\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void queryForInt1() {\r\n\r\n        int i = jdbcTemplate.queryForInt(\"select count(0) from person where name = ?\", new Object[] { \"zhu\" });\r\n\r\n        System.out.println(i);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void queryForObject2() {\r\n\r\n        String p = jdbcTemplate.queryForObject(\"select name from person where id = 3\", String.class);\r\n\r\n        System.out.println(p);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void queryForObject3() { //\r\n\r\n        Person p = (Person) jdbcTemplate.queryForObject(\"select * from person where id = 3\", new RowMapper<Person>() {\r\n\r\n            @Override\r\n\r\n            public Person mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\r\n                Person user = new Person();\r\n\r\n                user.setId(rs.getInt(\"id\"));\r\n\r\n                user.setName(rs.getString(\"name\"));\r\n\r\n                user.setPass(rs.getString(\"pass\"));\r\n\r\n                user.setAge(rs.getInt(\"age\"));\r\n\r\n                return user;\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(p);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void queryForList2() {\r\n\r\n        List<String> list = (List<String>) jdbcTemplate.queryForList(\"select name from person \", String.class);\r\n\r\n        System.out.println(list);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void queryForList3() { // 不行\r\n\r\n        List<Person> list = (List<Person>) jdbcTemplate.queryForList(\"select * from person \", Person.class);\r\n\r\n        System.out.println(list);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void getPersonInfo() {\r\n\r\n        List<Map<String, Object>> list = this.jdbcTemplate.queryForList(\"select * from person\");\r\n\r\n        System.out.println(list);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testBeanPropertyRowMapper() { // 推荐,返回 对象list\r\n\r\n        Collection<Integer> arr = new ArrayList<>();\r\n\r\n        arr.add(2);\r\n\r\n        arr.add(3);\r\n\r\n        List<Person> result = jdbcTemplate.query(\"select * from person where id >?\", new Object[] { 2 },\r\n\r\n                new BeanPropertyRowMapper<Person>(Person.class));\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testColumnMapRowMapper() { // 返回对象map\r\n\r\n        List<Map<String, Object>> result = jdbcTemplate.query(\"select * from person\", new ColumnMapRowMapper());\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testSingleColumnRowMapper() { // 返回一列集合\r\n\r\n        List<String> result1 = jdbcTemplate.query(\"select name from person\", new SingleColumnRowMapper<String>());\r\n\r\n        System.out.println(result1);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void list1() { // 查询结果\r\n\r\n        List<Person> list = (List<Person>) jdbcTemplate.query(\"select * from person\", new RowMapper<Person>() {\r\n\r\n            @Override\r\n\r\n            public Person mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n\r\n                Person user = new Person();\r\n\r\n                user.setId(rs.getInt(\"id\"));\r\n\r\n                user.setAge(rs.getInt(\"age\"));\r\n\r\n                user.setName(rs.getString(\"name\"));\r\n\r\n                user.setPass(rs.getString(\"pass\"));\r\n\r\n                return user;\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(list);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void batchUpdate() {\r\n\r\n        List<Person> list = new ArrayList<>();\r\n\r\n        Person p = new Person();\r\n\r\n        p.setId(6);\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Edddddddada\");\r\n\r\n        p.setPass(\"232323\");\r\n\r\n        list.add(p);\r\n\r\n        int[] updateCounts = jdbcTemplate.batchUpdate(\"update person set name = ?, pass = ? where id = ?\",\r\n\r\n                new BatchPreparedStatementSetter() {\r\n\r\n                    @Override\r\n\r\n                    public void setValues(PreparedStatement ps, int i) throws SQLException {\r\n\r\n                        ps.setString(1, ((Person) list.get(i)).getName());\r\n\r\n                        ps.setString(2, ((Person) list.get(i)).getPass());\r\n\r\n                        ps.setLong(3, ((Person) list.get(i)).getId());\r\n\r\n                    }\r\n\r\n \r\n\r\n                    @Override\r\n\r\n                    public int getBatchSize() {\r\n\r\n                        return list.size();\r\n\r\n                    }\r\n\r\n                });\r\n\r\n \r\n\r\n        System.out.println(Arrays.toString(updateCounts));\r\n\r\n    }\r\n\r\n \r\n\r\n} \r\n\r\n\r\npackage jdbc;\r\n\r\n \r\n\r\nimport java.sql.PreparedStatement;\r\n\r\nimport java.sql.ResultSet;\r\n\r\nimport java.sql.SQLException;\r\n\r\nimport java.util.ArrayList;\r\n\r\nimport java.util.Collection;\r\n\r\nimport java.util.HashMap;\r\n\r\nimport java.util.List;\r\n\r\nimport java.util.Map;\r\n\r\n \r\n\r\nimport org.junit.Test;\r\n\r\nimport org.junit.runner.RunWith;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\nimport org.springframework.dao.DataAccessException;\r\n\r\nimport org.springframework.jdbc.core.BatchPreparedStatementSetter;\r\n\r\nimport org.springframework.jdbc.core.BeanPropertyRowMapper;\r\n\r\nimport org.springframework.jdbc.core.JdbcTemplate;\r\n\r\nimport org.springframework.jdbc.core.ResultSetExtractor;\r\n\r\nimport org.springframework.jdbc.core.RowCallbackHandler;\r\n\r\nimport org.springframework.jdbc.core.RowMapper;\r\n\r\nimport org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;\r\n\r\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;\r\n\r\nimport org.springframework.jdbc.core.namedparam.SqlParameterSource;\r\n\r\nimport org.springframework.jdbc.support.GeneratedKeyHolder;\r\n\r\nimport org.springframework.jdbc.support.KeyHolder;\r\n\r\nimport org.springframework.test.context.ContextConfiguration;\r\n\r\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\r\n\r\n \r\n\r\nimport jdbc.model.Person;\r\n\r\nimport jdbc.service.PersonService;\r\n\r\n \r\n\r\n@ContextConfiguration(locations = \"classpath:beans.xml\")\r\n\r\n@RunWith(SpringJUnit4ClassRunner.class)\r\n\r\npublic class NamedParameterJdbcTemplateTest {\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private JdbcTemplate jdbcTemplate;\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private NamedParameterJdbcTemplate namedParameterJdbcTemplate;\r\n\r\n \r\n\r\n    @Autowired\r\n\r\n    private PersonService personService;\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testInsertSql() {\r\n\r\n        String insertSql = \"insert into person (name,age,pass) values(:name,:age,:pass);\";\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"name\", \"Aily\");\r\n\r\n        paramMap.put(\"age\", 22);\r\n\r\n        paramMap.put(\"pass\", \"333\");\r\n\r\n        namedParameterJdbcTemplate.update(insertSql, paramMap);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void addStu() {\r\n\r\n \r\n\r\n        String sql = \"insert into person (name,age,pass) values(:name,:age,:pass)\";\r\n\r\n \r\n\r\n        Person p = new Person();\r\n\r\n        p.setAge(11);\r\n\r\n        p.setName(\"Edddad\");\r\n\r\n        p.setPass(\"000ddd00\");\r\n\r\n \r\n\r\n        SqlParameterSource ps = new BeanPropertySqlParameterSource(p);\r\n\r\n \r\n\r\n        KeyHolder keyholder = new GeneratedKeyHolder();\r\n\r\n \r\n\r\n        namedParameterJdbcTemplate.update(sql, ps, keyholder);\r\n\r\n        int m = keyholder.getKey().intValue();\r\n\r\n \r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testupdate() {\r\n\r\n        String updatesql = \"update person set age = :age where id > :id \";\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"id\", 4);\r\n\r\n        paramMap.put(\"age\", 10);\r\n\r\n        namedParameterJdbcTemplate.update(updatesql, paramMap);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testupdate1() {\r\n\r\n        String updatesql = \"update person set age = ? where id > ? \";\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"id\", 4);\r\n\r\n        paramMap.put(\"age\", 20);\r\n\r\n        jdbcTemplate.batchUpdate(updatesql, new BatchPreparedStatementSetter() {\r\n\r\n            @Override\r\n\r\n            public int getBatchSize() {\r\n\r\n                return paramMap.size();\r\n\r\n            }\r\n\r\n \r\n\r\n            @Override\r\n\r\n            public void setValues(PreparedStatement ps, int i) throws SQLException {\r\n\r\n                ps.setInt(1, (int) paramMap.get(\"age\"));\r\n\r\n                ps.setInt(2, (int) paramMap.get(\"id\"));\r\n\r\n            }\r\n\r\n        });\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void tes1queryq() {\r\n\r\n        String selectSql = \"select id,name from person where name=:name\";\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"name\", \"Ead\");\r\n\r\n        List<Integer> result = new ArrayList<Integer>();\r\n\r\n        namedParameterJdbcTemplate.query(selectSql, paramMap, new RowCallbackHandler() {\r\n\r\n            @Override\r\n\r\n            public void processRow(ResultSet rs) throws SQLException {\r\n\r\n                result.add(rs.getInt(\"id\"));\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void tes1queryq1() {\r\n\r\n        String selectSql = \"select id,name from person where id IN (:ids)\";\r\n\r\n        Collection<Integer> arr = new ArrayList<>();\r\n\r\n        arr.add(2);\r\n\r\n        arr.add(3);\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"ids\", arr);\r\n\r\n        List<Integer> result = new ArrayList<Integer>();\r\n\r\n        namedParameterJdbcTemplate.query(selectSql, paramMap, new RowCallbackHandler() {\r\n\r\n            @Override\r\n\r\n            public void processRow(ResultSet rs) throws SQLException {\r\n\r\n                result.add(rs.getInt(\"id\"));\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testquery2() {\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"id\", 4);\r\n\r\n        String sql = \"select name,age,pass from person  \" + \"where id > :id\";\r\n\r\n        List<Map<String, Object>> result = namedParameterJdbcTemplate.queryForList(sql, paramMap);\r\n\r\n        for (Map<String, Object> map : result) {\r\n\r\n            System.out.println(\"------------\");\r\n\r\n            System.out.println(map.get(\"name\"));\r\n\r\n            System.out.println(map.get(\"age\"));\r\n\r\n            System.out.println(map.get(\"pass\"));\r\n\r\n        }\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testdeleteSql() {\r\n\r\n        String deleteSql = \"delete from test where name=:name\";\r\n\r\n        Map<String, Object> paramMap = new HashMap<String, Object>();\r\n\r\n        paramMap.put(\"name\", \"Ead\");\r\n\r\n        namedParameterJdbcTemplate.update(deleteSql, paramMap);\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testBeanPropertyRowMapper() { // 推荐,返回 对象list\r\n\r\n        List<Person> result = namedParameterJdbcTemplate.query(\"select * from person\",\r\n\r\n                new BeanPropertyRowMapper<Person>(Person.class));\r\n\r\n        System.out.println(result);\r\n\r\n    }\r\n\r\n \r\n\r\n    /*-------------------三种结果集的查询使用------------*/\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testResultSetExtractor() {\r\n\r\n        List<Person> list = (List<Person>) jdbcTemplate.query(\"select * from person\",\r\n\r\n                new ResultSetExtractor<List<Person>>() {\r\n\r\n                    public List<Person> extractData(ResultSet rs) throws SQLException, DataAccessException {\r\n\r\n                        List<Person> ps = new ArrayList<>();\r\n\r\n                        while (rs.next()) {\r\n\r\n                            Person p = new Person();\r\n\r\n                            p.setId(rs.getInt(\"id\"));\r\n\r\n                            p.setName(rs.getString(\"name\"));\r\n\r\n                            p.setAge(rs.getInt(\"age\"));\r\n\r\n                            p.setPass(rs.getString(\"pass\"));\r\n\r\n                            ps.add(p);\r\n\r\n                        }\r\n\r\n                        return ps;\r\n\r\n                    }\r\n\r\n                });\r\n\r\n        System.out.println(list);// 返回整个查询结果\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testRowMapper() {\r\n\r\n        List<Person> list = jdbcTemplate.query(\"select * from person\", new RowMapper<Person>() {\r\n\r\n            public Person mapRow(ResultSet rs, int rowNumber) throws SQLException {\r\n\r\n                Person p = new Person();\r\n\r\n                p.setId(rs.getInt(\"id\"));\r\n\r\n                p.setName(rs.getString(\"name\"));\r\n\r\n                p.setAge(rs.getInt(\"age\"));\r\n\r\n                p.setPass(rs.getString(\"pass\"));\r\n\r\n                return p;\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(list);// 返回整个查询结果\r\n\r\n    }\r\n\r\n \r\n\r\n    @Test\r\n\r\n    public void testRowCallbackHandler() {\r\n\r\n        List<Person> list = new ArrayList<>();\r\n\r\n        jdbcTemplate.query(\"select * from person\", new RowCallbackHandler() {\r\n\r\n            public void processRow(ResultSet rs) throws SQLException {\r\n\r\n                Person p = new Person();\r\n\r\n                p.setId(rs.getInt(\"id\"));\r\n\r\n                p.setName(rs.getString(\"name\"));\r\n\r\n                p.setAge(rs.getInt(\"age\"));\r\n\r\n                p.setPass(rs.getString(\"pass\"));\r\n\r\n                list.add(p);\r\n\r\n            }\r\n\r\n        });\r\n\r\n        System.out.println(list);// 返回整个查询结果\r\n\r\n    }\r\n\r\n \r\n\r\n} \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}